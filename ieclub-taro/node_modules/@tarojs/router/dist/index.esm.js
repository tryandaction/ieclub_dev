import { defineCustomElementTaroTabbar } from '@tarojs/components/dist/components';
import { initTabBarApis } from '@tarojs/taro';
import { __awaiter } from 'tslib';
import { addLeadingSlash, Current, stripBasename, incrementId, eventCenter, createPageConfig, hooks, stringify, getHomePage, getCurrentPage, stripTrailing, requestAnimationFrame as requestAnimationFrame$1 } from '@tarojs/runtime';
import { createBrowserHistory, createHashHistory, Action, parsePath } from 'history';
export { createBrowserHistory, createHashHistory } from 'history';
import queryString from 'query-string';
import UniversalRouter from 'universal-router';

function initTabbar(config, history) {
    if (config.tabBar == null) {
        return;
    }
    // TODO: custom-tab-bar
    defineCustomElementTaroTabbar();
    const tabbar = document.createElement('taro-tabbar');
    const homePage = config.entryPagePath || (config.pages ? config.pages[0] : '');
    tabbar.conf = config.tabBar;
    tabbar.conf.homePage = history.location.pathname === '/' ? homePage : history.location.pathname;
    const routerConfig = config.router;
    tabbar.conf.mode = routerConfig && routerConfig.mode ? routerConfig.mode : 'hash';
    if (routerConfig.customRoutes) {
        tabbar.conf.custom = true;
        tabbar.conf.customRoutes = routerConfig.customRoutes;
    }
    else {
        tabbar.conf.custom = false;
        tabbar.conf.customRoutes = {};
    }
    if (typeof routerConfig.basename !== 'undefined') {
        tabbar.conf.basename = routerConfig.basename;
    }
    const container = document.getElementById('container');
    container === null || container === void 0 ? void 0 : container.appendChild(tabbar);
    initTabBarApis(config);
}

class RouterConfig {
    static set config(e) {
        this.__config = e;
    }
    static get config() {
        return this.__config;
    }
    static get pages() {
        return this.config.pages || [];
    }
    static get router() {
        return this.config.router || {};
    }
    static get mode() {
        return this.router.mode || 'hash';
    }
    static get customRoutes() { return this.router.customRoutes || {}; }
    static isPage(url = '') {
        return this.pages.findIndex(e => addLeadingSlash(e) === url) !== -1;
    }
}

let history;
let basename = '/';
class MpaHistory {
    constructor() {
        this.back = window.history.back;
        this.forward = window.history.forward;
        this.pushState = this.eventState('pushState');
        this.replaceState = this.eventState('replaceState');
    }
    get location() {
        return {
            pathname: window.location.pathname,
            search: window.location.search,
            hash: window.location.hash,
            key: `${window.history.length}`,
            state: window.history.state
        };
    }
    createHref(_to) {
        throw new Error('Method not implemented.');
    }
    parseUrl(to) {
        let url = to.pathname || '';
        if (RouterConfig.isPage(url)) {
            url += '.html';
        }
        if (to.search) {
            url += `?${to.search}`;
        }
        if (to.hash) {
            url += `#${to.hash}`;
        }
        return url;
    }
    push(to, _state = {}) {
        window.location.assign(this.parseUrl(to));
        // this.pushState(_state, '', this.parseUrl(to))
    }
    replace(to, _state = {}) {
        window.location.replace(this.parseUrl(to));
        // this.replaceState(_state, '', this.parseUrl(to))
    }
    go(delta) {
        window.history.go(delta);
    }
    listen(listener) {
        function callback(e) {
            if (e.action === 'pushState') {
                listener({ action: Action.Push, location: this.location });
            }
            else if (e.action === 'replaceState') {
                listener({ action: Action.Replace, location: this.location });
            }
            else {
                // NOTE: 这里包括 back、forward、go 三种可能，并非是 POP 事件
                listener({ action: Action.Pop, location: this.location });
            }
        }
        window.addEventListener('popstate', callback);
        return () => {
            window.removeEventListener('popstate', callback);
        };
    }
    block(_blocker) {
        throw new Error('Method not implemented.');
    }
    eventState(action) {
        return (data, unused, url) => {
            const wrapper = window.history[action](data, unused, url);
            const evt = new Event(action);
            evt.action = action;
            evt.state = data;
            evt.unused = unused;
            evt.url = url;
            window.dispatchEvent(evt);
            return wrapper;
        };
    }
}
function setHistory(h, base = '/') {
    history = h;
    basename = base;
}
function createMpaHistory(_) {
    return new MpaHistory();
}
function setHistoryMode(mode, base = '/') {
    const options = {
        window
    };
    basename = base;
    if (mode === 'browser') {
        history = createBrowserHistory(options);
    }
    else if (mode === 'multi') {
        history = createMpaHistory();
    }
    else {
        // default is hash
        history = createHashHistory(options);
    }
}
function prependBasename(url = '') {
    return basename.replace(/\/$/, '') + '/' + url.replace(/^\//, '');
}

class Stacks {
    constructor() {
        this.stacks = [];
        this.backDelta = 0;
        this.tabs = {};
        this.methodName = '';
    }
    set delta(delta) {
        if (delta > 0) {
            this.backDelta = delta;
        }
        else if (this.backDelta > 0) {
            --this.backDelta;
        }
        else {
            this.backDelta = 0;
        }
    }
    get delta() {
        return this.backDelta;
    }
    set method(methodName) {
        this.methodName = methodName;
    }
    get method() {
        return this.methodName;
    }
    get length() {
        return this.stacks.length;
    }
    get last() {
        return this.stacks[this.length - 1];
    }
    get() {
        return this.stacks;
    }
    getItem(index) {
        return this.stacks[index];
    }
    getLastIndex(pathname, stateWith = 1) {
        const list = [...this.stacks].reverse();
        return list.findIndex((page, i) => { var _a; return i >= stateWith && ((_a = page.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, '')) === pathname; });
    }
    getDelta(pathname) {
        if (this.backDelta >= 1) {
            return this.backDelta;
        }
        const index = this.getLastIndex(pathname);
        // NOTE: 此处为了修复浏览器后退多级页面，在大量重复路由状况下可能出现判断错误的情况 （增强判断能力只能考虑在 query 中新增参数来判断，暂时搁置）
        return index > 0 ? index : 1;
    }
    getPrevIndex(pathname, stateWith = 1) {
        const lastIndex = this.getLastIndex(pathname, stateWith);
        if (lastIndex < 0) {
            return -1;
        }
        return this.length - 1 - lastIndex;
    }
    pop() {
        return this.stacks.pop();
    }
    push(page) {
        return this.stacks.push(page);
    }
    getTabs() {
        return this.tabs;
    }
    pushTab(path) {
        this.tabs[path] = this.last;
        this.pop();
    }
    popTab(path) {
        this.push(this.tabs[path]);
        delete this.tabs[path];
    }
    removeTab(path) {
        delete this.tabs[path];
    }
}
const stacks = new Stacks();

let preTitle = document.title;
let isLoadDdEntry = false;
const isWeixin = () => !!navigator.userAgent.match(/\bMicroMessenger\b/ig);
const isDingTalk = () => !!navigator.userAgent.match(/\bDingTalk\b/ig);
function setTitle(title) {
    return __awaiter(this, void 0, void 0, function* () {
        if (preTitle === title)
            return title;
        document.title = title;
        preTitle = title;
        if (process.env.SUPPORT_DINGTALK_NAVIGATE !== 'disabled' && isDingTalk()) {
            if (!isLoadDdEntry) {
                isLoadDdEntry = true;
                require('dingtalk-jsapi/platform');
            }
            const setDingTitle = require('dingtalk-jsapi/api/biz/navigation/setTitle').default;
            setDingTitle({ title });
        }
        return title;
    });
}

class RoutesAlias {
    constructor() {
        this.conf = [];
        this.getConfig = (url = '') => {
            const customRoute = this.conf.filter((arr) => {
                return arr.includes(url);
            });
            return customRoute[0];
        };
        this.getOrigin = (url = '') => {
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[0]) || url;
        };
        this.getAlias = (url = '') => {
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[1]) || url;
        };
        this.getAll = (url = '') => {
            return this.conf
                .filter((arr) => arr.includes(url))
                .reduceRight((p, a) => {
                p.unshift(a[1]);
                return p;
            }, []);
        };
    }
    set(customRoutes = {}) {
        for (let key in customRoutes) {
            const path = customRoutes[key];
            key = addLeadingSlash(key);
            if (typeof path === 'string') {
                this.conf.push([key, addLeadingSlash(path)]);
            }
            else if ((path === null || path === void 0 ? void 0 : path.length) > 0) {
                this.conf.push(...path.map(p => [key, addLeadingSlash(p)]));
            }
        }
    }
}
const routesAlias = new RoutesAlias();

function processNavigateUrl(option) {
    var _a;
    const pathPieces = parsePath(option.url);
    // 处理相对路径
    if ((_a = pathPieces.pathname) === null || _a === void 0 ? void 0 : _a.includes('./')) {
        const parts = routesAlias.getOrigin(history.location.pathname).split('/');
        parts.pop();
        pathPieces.pathname.split('/').forEach((item) => {
            if (item === '.') {
                return;
            }
            item === '..' ? parts.pop() : parts.push(item);
        });
        pathPieces.pathname = parts.join('/');
    }
    // 处理自定义路由
    pathPieces.pathname = routesAlias.getAlias(addLeadingSlash(pathPieces.pathname));
    // 处理 basename
    pathPieces.pathname = prependBasename(pathPieces.pathname);
    // hack fix history v5 bug: https://github.com/remix-run/history/issues/814
    if (!pathPieces.search)
        pathPieces.search = '';
    return pathPieces;
}
function navigate(option, method) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            stacks.method = method;
            const { success, complete, fail } = option;
            const unListen = history.listen(() => {
                const res = { errMsg: `${method}:ok` };
                success === null || success === void 0 ? void 0 : success(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                resolve(res);
                unListen();
            });
            try {
                if ('url' in option) {
                    const pathPieces = processNavigateUrl(option);
                    const state = { timestamp: Date.now() };
                    if (method === 'navigateTo') {
                        history.push(pathPieces, state);
                    }
                    else if (method === 'redirectTo' || method === 'switchTab') {
                        history.replace(pathPieces, state);
                    }
                    else if (method === 'reLaunch') {
                        stacks.delta = stacks.length;
                        history.replace(pathPieces, state);
                    }
                }
                else if (method === 'navigateBack') {
                    stacks.delta = option.delta;
                    if (stacks.length > option.delta) {
                        history.go(-option.delta);
                    }
                    else {
                        history.go(1 - stacks.length);
                    }
                }
            }
            catch (error) {
                const res = { errMsg: `${method}:fail ${error.message || error}` };
                fail === null || fail === void 0 ? void 0 : fail(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                reject(res);
            }
        });
    });
}
function navigateTo(option) {
    return navigate(option, 'navigateTo');
}
function redirectTo(option) {
    return navigate(option, 'redirectTo');
}
function navigateBack(option = { delta: 1 }) {
    if (!option.delta || option.delta < 1) {
        option.delta = 1;
    }
    return navigate(option, 'navigateBack');
}
function switchTab(option) {
    return navigate(option, 'switchTab');
}
function reLaunch(option) {
    return navigate(option, 'reLaunch');
}
function getCurrentPages() {
    if (process.env.NODE_ENV !== 'production' && RouterConfig.mode === 'multi') {
        console.warn('多页面路由模式不支持使用 getCurrentPages 方法！');
    }
    const pages = stacks.get();
    return pages.map(e => { var _a; return (Object.assign(Object.assign({}, e), { route: ((_a = e.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, '')) || '' })); });
}

let pageResizeFn;
function bindPageResize(page) {
    pageResizeFn && window.removeEventListener('resize', pageResizeFn);
    pageResizeFn = function () {
        page.onResize && page.onResize({
            size: {
                windowHeight: window.innerHeight,
                windowWidth: window.innerWidth
            }
        });
    };
    window.addEventListener('resize', pageResizeFn, false);
}

const pageScrollFn = {};
let pageDOM = window;
function bindPageScroll(page, scrollEl, distance = 50) {
    var _a;
    const pagePath = (page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.router) === null || _a === void 0 ? void 0 : _a.path);
    pageScrollFn[pagePath] && scrollEl.removeEventListener('scroll', pageScrollFn[pagePath]);
    pageDOM = scrollEl;
    let isReachBottom = false;
    pageScrollFn[pagePath] = function () {
        var _a;
        (_a = page.onPageScroll) === null || _a === void 0 ? void 0 : _a.call(page, {
            scrollTop: pageDOM instanceof Window ? window.scrollY : pageDOM.scrollTop
        });
        if (isReachBottom && getOffset() > distance) {
            isReachBottom = false;
        }
        if (page.onReachBottom &&
            !isReachBottom &&
            getOffset() < distance) {
            isReachBottom = true;
            page.onReachBottom();
        }
    };
    pageDOM.addEventListener('scroll', pageScrollFn[pagePath], false);
}
function getOffset() {
    if (pageDOM instanceof Window) {
        return document.documentElement.scrollHeight - window.scrollY - window.innerHeight;
    }
    else {
        return pageDOM.scrollHeight - pageDOM.scrollTop - pageDOM.clientHeight;
    }
}

/**
 * 插入页面动画需要的样式
 */
function loadAnimateStyle(ms = 300) {
    const css = `
body {
  overflow: hidden; // 防止 iOS 页面滚动
}
.taro_router > .taro_page {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: #fff;
  transform: translate(100%, 0);
  transition: transform ${ms}ms;
  z-index: 0;
}

.taro_router > .taro_page.taro_tabbar_page,
.taro_router > .taro_page.taro_page_show.taro_page_stationed {
  transform: none;
}

.taro_router > .taro_page.taro_page_show {
  transform: translate(0, 0);
}
`;
    addStyle(css);
}
/**
 * 插入路由相关样式
 */
function loadRouterStyle(enableTabBar, enableWindowScroll) {
    const css = `
  .taro_router {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .taro_page {
    width: 100%;
    height: 100%;
${enableWindowScroll ? '' : `
    overflow-x: hidden;
    overflow-y: scroll;
    max-height: 100vh;
`}
  }
${enableTabBar ? `
  .taro-tabbar__container > .taro-tabbar__panel {
    overflow: hidden;
  }

  .taro-tabbar__container > .taro-tabbar__panel > .taro_page.taro_tabbar_page {
    max-height: calc(100vh - var(--taro-tabbar-height) - constant(safe-area-inset-bottom));
    max-height: calc(100vh - var(--taro-tabbar-height) - env(safe-area-inset-bottom));
  }

` : ''}
  .taro_page_shade,
  .taro_router > .taro_page.taro_page_show.taro_page_stationed:not(.taro_page_shade):not(.taro_tabbar_page):not(:last-child) {
    display: none;
  }
`;
    addStyle(css);
}
function addStyle(css) {
    if (!css)
        return;
    const style = document.createElement('style');
    style.innerHTML = css;
    document.getElementsByTagName('head')[0].appendChild(style);
}

/* eslint-disable dot-notation */
class MultiPageHandler {
    constructor(config, history) {
        this.history = history;
        this.config = config;
        this.mount();
    }
    get appId() { return this.config.appId || 'app'; }
    get router() { return this.config.router || {}; }
    get routerMode() { return this.router.mode || 'hash'; }
    get customRoutes() { return this.router.customRoutes || {}; }
    get tabBarList() { var _a; return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || []; }
    get PullDownRefresh() { return this.config.PullDownRefresh; }
    set pathname(p) { this.router.pathname = p; }
    get pathname() { return this.router.pathname; }
    get basename() { return this.router.basename || ''; }
    get pageConfig() { return this.config.route; }
    get isTabBar() {
        var _a;
        const routePath = addLeadingSlash(stripBasename(this.pathname, this.basename));
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target]) => {
            if (typeof target === 'string') {
                return target === routePath;
            }
            else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some(t => t.pagePath === pagePath);
    }
    get search() { return location.search.substr(1); }
    get usingWindowScroll() {
        var _a;
        let usingWindowScroll = true;
        if (typeof ((_a = this.pageConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll) === 'boolean') {
            usingWindowScroll = this.pageConfig.usingWindowScroll;
        }
        const win = window;
        win.__taroAppConfig || (win.__taroAppConfig = {});
        win.__taroAppConfig.usingWindowScroll = usingWindowScroll;
        return usingWindowScroll;
    }
    getQuery(search = '', options = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search
            ? queryString.parse(search)
            : {};
        return Object.assign(Object.assign({}, query), options);
    }
    isDefaultNavigationStyle() {
        var _a, _b;
        let style = (_a = this.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
        if (typeof ((_b = this.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === 'string') {
            style = this.pageConfig.navigationStyle;
        }
        return style !== 'custom';
    }
    mount() {
        setHistory(this.history, this.basename);
        // Note: 注入页面样式
        loadRouterStyle(this.tabBarList.length > 1, this.usingWindowScroll);
    }
    onReady(page, onLoad = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl['__isReady'])) {
            const el = pageEl.firstElementChild;
            const componentOnReady = el === null || el === void 0 ? void 0 : el['componentOnReady'];
            if (componentOnReady) {
                componentOnReady === null || componentOnReady === void 0 ? void 0 : componentOnReady().then(() => {
                    requestAnimationFrame(() => {
                        var _a;
                        (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                        pageEl['__isReady'] = true;
                    });
                });
            }
            else {
                (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                pageEl['__isReady'] = true;
            }
            onLoad && (pageEl['__page'] = page);
        }
    }
    load(page, pageConfig = {}) {
        var _a;
        if (!page)
            return;
        (_a = page.onLoad) === null || _a === void 0 ? void 0 : _a.call(page, this.getQuery('', page.options), () => {
            var _a;
            const pageEl = this.getPageContainer(page);
            if (this.isTabBar) {
                pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add('taro_tabbar_page');
            }
            if (this.isDefaultNavigationStyle()) {
                pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add('taro_navigation_page');
            }
            this.onReady(page, true);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageConfig);
        });
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, '\\$1');
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = (id
            ? document.querySelector(`.taro_page#${id}`)
            : document.querySelector('.taro_page') ||
                document.querySelector('.taro_router'));
        return el;
    }
    getScrollingElement(page) {
        if (this.usingWindowScroll)
            return window;
        return this.getPageContainer(page) || window;
    }
    bindPageEvents(page, config = {}) {
        var _a;
        const scrollEl = this.getScrollingElement(page);
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, scrollEl, distance);
        bindPageResize(page);
    }
}

const createStampId$1 = incrementId();
const launchStampId$1 = createStampId$1();
// TODO 支持多路由 (APP 生命周期仅触发一次)
/** Note: 关于多页面应用
 * - 需要配置路由映射（根目录跳转、404 页面……）
 * - app.onPageNotFound 事件不支持
 * - 应用生命周期可能多次触发
 * - TabBar 会多次加载
 * - 不支持路由动画
 */
function createMultiRouter(history, app, config, framework) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof app.onUnhandledRejection === 'function') {
            window.addEventListener('unhandledrejection', app.onUnhandledRejection);
        }
        RouterConfig.config = config;
        const handler = new MultiPageHandler(config, history);
        const launchParam = {
            path: config.pageName,
            query: handler.getQuery(launchStampId$1),
            scene: 0,
            shareTicket: '',
            referrerInfo: {}
        };
        eventCenter.trigger('__taroRouterLaunch', launchParam);
        (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
        app.onError && window.addEventListener('error', e => { var _a; return (_a = app.onError) === null || _a === void 0 ? void 0 : _a.call(app, e.message); });
        const pathName = config.pageName;
        const pageConfig = handler.pageConfig;
        eventCenter.trigger('__taroRouterChange', {
            toLocation: {
                path: pathName
            }
        });
        let element;
        try {
            element = yield ((_b = pageConfig.load) === null || _b === void 0 ? void 0 : _b.call(pageConfig));
            if (element instanceof Array) {
                element = element[0];
            }
        }
        catch (error) {
            throw new Error(error);
        }
        if (!element)
            return;
        let enablePullDownRefresh = ((_c = config === null || config === void 0 ? void 0 : config.window) === null || _c === void 0 ? void 0 : _c.enablePullDownRefresh) || false;
        if (pageConfig) {
            setTitle((_d = pageConfig.navigationBarTitleText) !== null && _d !== void 0 ? _d : document.title);
            if (typeof pageConfig.enablePullDownRefresh === 'boolean') {
                enablePullDownRefresh = pageConfig.enablePullDownRefresh;
            }
        }
        const el = (_e = element.default) !== null && _e !== void 0 ? _e : element;
        const loadConfig = Object.assign({}, pageConfig);
        delete loadConfig['path'];
        delete loadConfig['load'];
        const page = createPageConfig(enablePullDownRefresh ? hooks.call('createPullDownComponent', el, pathName, framework, handler.PullDownRefresh) : el, pathName + stringify(launchParam), {}, loadConfig);
        handler.load(page, pageConfig);
        (_f = app.onShow) === null || _f === void 0 ? void 0 : _f.call(app, launchParam);
    });
}

/* eslint-disable dot-notation */
class PageHandler {
    constructor(config, history) {
        this.history = history;
        this.defaultAnimation = { duration: 300, delay: 50 };
        this.config = config;
        this.homePage = getHomePage(this.routes[0].path, this.basename, this.customRoutes, this.config.entryPagePath);
        this.mount();
    }
    get currentPage() {
        const routePath = getCurrentPage(this.routerMode, this.basename);
        return routePath === '/' ? this.homePage : routePath;
    }
    get appId() { return this.config.appId || 'app'; }
    get router() { return this.config.router || {}; }
    get routerMode() { return this.router.mode || 'hash'; }
    get customRoutes() { return this.router.customRoutes || {}; }
    get routes() { return this.config.routes || []; }
    get tabBarList() { var _a; return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || []; }
    get PullDownRefresh() { return this.config.PullDownRefresh; }
    get animation() { var _a, _b; return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.defaultAnimation; }
    get animationDelay() {
        var _a;
        return (typeof this.animation === 'object'
            ? this.animation.delay
            : this.animation
                ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.delay
                : 0) || 0;
    }
    get animationDuration() {
        var _a;
        return (typeof this.animation === 'object'
            ? this.animation.duration
            : this.animation
                ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.duration
                : 0) || 0;
    }
    set pathname(p) { this.router.pathname = p; }
    get pathname() { return this.router.pathname; }
    get basename() { return this.router.basename || ''; }
    get pageConfig() {
        const routePath = addLeadingSlash(stripBasename(this.pathname, this.basename));
        const homePage = addLeadingSlash(this.homePage);
        return this.routes.find(r => {
            var _a;
            const pagePath = addLeadingSlash(r.path);
            return [pagePath, homePage].includes(routePath) || ((_a = routesAlias.getConfig(pagePath)) === null || _a === void 0 ? void 0 : _a.includes(routePath));
        });
    }
    isTabBar(pathname) {
        var _a;
        const routePath = addLeadingSlash(stripBasename(pathname, this.basename)).split('?')[0];
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target]) => {
            if (typeof target === 'string') {
                return target === routePath;
            }
            else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some(t => stripTrailing(t.pagePath) === pagePath);
    }
    isDefaultNavigationStyle() {
        var _a, _b;
        let style = (_a = this.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
        if (typeof ((_b = this.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === 'string') {
            style = this.pageConfig.navigationStyle;
        }
        return style !== 'custom';
    }
    isSamePage(page) {
        const routePath = stripBasename(this.pathname, this.basename);
        const pagePath = stripBasename(page === null || page === void 0 ? void 0 : page.path, this.basename);
        return pagePath.startsWith(routePath + '?');
    }
    get search() {
        let search = '?';
        if (this.routerMode === 'hash') {
            const idx = location.hash.indexOf('?');
            if (idx > -1) {
                search = location.hash.slice(idx);
            }
        }
        else {
            search = location.search;
        }
        return search.substring(1);
    }
    get usingWindowScroll() {
        var _a;
        let usingWindowScroll = false;
        if (typeof ((_a = this.pageConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll) === 'boolean') {
            usingWindowScroll = this.pageConfig.usingWindowScroll;
        }
        const win = window;
        win.__taroAppConfig || (win.__taroAppConfig = {});
        win.__taroAppConfig.usingWindowScroll = usingWindowScroll;
        return usingWindowScroll;
    }
    getQuery(stamp = '', search = '', options = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search
            ? queryString.parse(search, { decode: false })
            : {};
        query.stamp = stamp;
        return Object.assign(Object.assign({}, query), options);
    }
    mount() {
        setHistory(this.history, this.basename);
        this.pathname = history.location.pathname;
        // Note: 注入页面样式
        this.animation && loadAnimateStyle(this.animationDuration);
        loadRouterStyle(this.tabBarList.length > 1, this.usingWindowScroll);
    }
    onReady(page, onLoad = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl['__isReady'])) {
            const el = pageEl.firstElementChild;
            const componentOnReady = el === null || el === void 0 ? void 0 : el['componentOnReady'];
            if (componentOnReady) {
                componentOnReady === null || componentOnReady === void 0 ? void 0 : componentOnReady().then(() => {
                    requestAnimationFrame$1(() => {
                        var _a;
                        (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                        pageEl['__isReady'] = true;
                    });
                });
            }
            else {
                (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                pageEl['__isReady'] = true;
            }
            onLoad && (pageEl['__page'] = page);
        }
    }
    load(page, pageConfig = {}, stampId, pageNo = 0) {
        var _a, _b;
        if (!page)
            return;
        // NOTE: 页面栈推入太晚可能导致 getCurrentPages 无法获取到当前页面实例
        stacks.push(page);
        const param = this.getQuery(stampId, '', page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            pageEl.classList.remove('taro_page_shade');
            this.isTabBar(this.pathname) && pageEl.classList.add('taro_tabbar_page');
            this.isDefaultNavigationStyle() && pageEl.classList.add('taro_navigation_page');
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        }
        else {
            // FIXME 在 iOS 端快速切换页面时，可能不会执行回调注入对应类名导致 TabBar 白屏
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, () => {
                var _a;
                pageEl = this.getPageContainer(page);
                this.isTabBar(this.pathname) && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add('taro_tabbar_page'));
                this.isDefaultNavigationStyle() && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add('taro_navigation_page'));
                this.addAnimation(pageEl, pageNo === 0);
                (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
                this.onReady(page, true);
                this.bindPageEvents(page, pageConfig);
                this.triggerRouterChange();
            });
        }
    }
    unload(page, delta = 1, top = false) {
        var _a, _b, _c;
        if (!page)
            return;
        stacks.delta = --delta;
        stacks.pop();
        if (this.animation && top) {
            if (this.unloadTimer) {
                clearTimeout(this.unloadTimer);
                (_b = (_a = this.lastUnloadPage) === null || _a === void 0 ? void 0 : _a.onUnload) === null || _b === void 0 ? void 0 : _b.call(_a);
                this.unloadTimer = null;
            }
            this.lastUnloadPage = page;
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove('taro_page_stationed');
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove('taro_page_show');
            if (pageEl) {
                pageEl.style.zIndex = '1';
            }
            this.unloadTimer = setTimeout(() => {
                var _a, _b;
                this.unloadTimer = null;
                (_b = (_a = this.lastUnloadPage) === null || _a === void 0 ? void 0 : _a.onUnload) === null || _b === void 0 ? void 0 : _b.call(_a);
                eventCenter.trigger('__taroPageOnShowAfterDestroyed');
            }, this.animationDuration);
        }
        else {
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove('taro_page_stationed');
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove('taro_page_show');
            (_c = page === null || page === void 0 ? void 0 : page.onUnload) === null || _c === void 0 ? void 0 : _c.call(page);
            setTimeout(() => {
                eventCenter.trigger('__taroPageOnShowAfterDestroyed');
            }, 0);
        }
        if (delta >= 1)
            this.unload(stacks.last, delta);
    }
    show(page, pageConfig = {}, pageNo = 0) {
        var _a, _b;
        if (!page)
            return;
        const param = this.getQuery(page['$taroParams']['stamp'], '', page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            pageEl.classList.remove('taro_page_shade');
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        }
        else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, () => {
                var _a;
                pageEl = this.getPageContainer(page);
                this.addAnimation(pageEl, pageNo === 0);
                (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
                this.onReady(page, false);
                this.bindPageEvents(page, pageConfig);
                this.triggerRouterChange();
            });
        }
    }
    hide(page) {
        var _a;
        if (!page)
            return;
        // NOTE: 修复多页并发问题，此处可能因为路由跳转过快，执行时页面可能还没有创建成功
        const pageEl = this.getPageContainer(page);
        if (pageEl) {
            if (this.hideTimer) {
                clearTimeout(this.hideTimer);
                this.hideTimer = null;
                pageEl.classList.add('taro_page_shade');
            }
            this.lastHidePage = pageEl;
            this.hideTimer = setTimeout(() => {
                this.hideTimer = null;
                pageEl.classList.add('taro_page_shade');
            }, this.animationDuration + this.animationDelay);
            (_a = page.onHide) === null || _a === void 0 ? void 0 : _a.call(page);
        }
        else {
            setTimeout(() => this.hide(page), 0);
        }
    }
    addAnimation(pageEl, first = false) {
        if (!pageEl)
            return;
        if (this.animation && !first) {
            setTimeout(() => {
                pageEl.classList.add('taro_page_show');
                setTimeout(() => {
                    pageEl.classList.add('taro_page_stationed');
                }, this.animationDuration);
            }, this.animationDelay);
        }
        else {
            pageEl.classList.add('taro_page_show');
            pageEl.classList.add('taro_page_stationed');
        }
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, '\\$1');
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = (id
            ? document.querySelector(`.taro_page#${id}`)
            : document.querySelector('.taro_page') ||
                document.querySelector('.taro_router'));
        return el;
    }
    getScrollingElement(page) {
        if (this.usingWindowScroll)
            return window;
        return this.getPageContainer(page) || window;
    }
    bindPageEvents(page, config = {}) {
        var _a;
        const scrollEl = this.getScrollingElement(page);
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, scrollEl, distance);
        bindPageResize(page);
    }
    triggerRouterChange() {
        /**
         * @tarojs/runtime 中生命周期跑在 promise 中，所以这里需要 setTimeout 延迟事件调用
         * TODO 考虑将生命周期返回 Promise，用于处理相关事件调用顺序
         */
        setTimeout(() => {
            eventCenter.trigger('__afterTaroRouterChange', {
                toLocation: {
                    path: this.pathname
                }
            });
        }, 0);
    }
}

const createStampId = incrementId();
let launchStampId = createStampId();
function createRouter(history, app, config, framework) {
    var _a, _b;
    if (typeof app.onUnhandledRejection === 'function') {
        window.addEventListener('unhandledrejection', app.onUnhandledRejection);
    }
    RouterConfig.config = config;
    const handler = new PageHandler(config, history);
    routesAlias.set(handler.router.customRoutes);
    const basename = handler.router.basename;
    const routes = handler.routes.map(route => {
        const routePath = addLeadingSlash(route.path);
        const paths = routesAlias.getAll(routePath);
        return {
            path: paths.length < 1 ? routePath : paths,
            action: route.load
        };
    });
    const router = new UniversalRouter(routes, { baseUrl: basename || '' });
    const launchParam = {
        path: handler.currentPage,
        query: handler.getQuery(launchStampId),
        scene: 0,
        shareTicket: '',
        referrerInfo: {}
    };
    eventCenter.trigger('__taroRouterLaunch', launchParam);
    (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
    app.onError && window.addEventListener('error', e => { var _a; return (_a = app.onError) === null || _a === void 0 ? void 0 : _a.call(app, e.message); });
    const render = ({ location, action }) => __awaiter(this, void 0, void 0, function* () {
        var _c, _d, _e, _f, _g, _h, _j, _k, _l;
        handler.pathname = decodeURI(location.pathname);
        if ((_c = window.__taroAppConfig) === null || _c === void 0 ? void 0 : _c.usingWindowScroll)
            window.scrollTo(0, 0);
        eventCenter.trigger('__taroRouterChange', {
            toLocation: {
                path: handler.pathname
            }
        });
        let element, params;
        try {
            const result = yield router.resolve(handler.router.forcePath || handler.pathname);
            [element, , params] = yield Promise.all(result);
        }
        catch (error) {
            if (error.status === 404) {
                const notFoundEvent = {
                    isEntryPage: stacks.length === 0,
                    path: handler.pathname,
                    query: handler.getQuery(createStampId()),
                };
                (_d = app.onPageNotFound) === null || _d === void 0 ? void 0 : _d.call(app, notFoundEvent);
                eventCenter.trigger('__taroRouterNotFound', notFoundEvent);
            }
            else if (/Loading hot update .* failed./.test(error.message)) {
                // NOTE: webpack5 与 prebundle 搭配使用时，开发环境下初次启动时偶发错误，由于 HMR 加载 chunk hash 错误，导致热更新失败
                window.location.reload();
            }
            else {
                throw error;
            }
        }
        if (!element)
            return;
        const pageConfig = handler.pageConfig;
        let enablePullDownRefresh = ((_e = config === null || config === void 0 ? void 0 : config.window) === null || _e === void 0 ? void 0 : _e.enablePullDownRefresh) || false;
        let navigationStyle = ((_f = config === null || config === void 0 ? void 0 : config.window) === null || _f === void 0 ? void 0 : _f.navigationStyle) || 'default';
        let navigationBarTextStyle = ((_g = config === null || config === void 0 ? void 0 : config.window) === null || _g === void 0 ? void 0 : _g.navigationBarTextStyle) || 'white';
        let navigationBarBackgroundColor = ((_h = config === null || config === void 0 ? void 0 : config.window) === null || _h === void 0 ? void 0 : _h.navigationBarBackgroundColor) || '#000000';
        if (pageConfig) {
            setTitle((_j = pageConfig.navigationBarTitleText) !== null && _j !== void 0 ? _j : document.title);
            if (typeof pageConfig.enablePullDownRefresh === 'boolean') {
                enablePullDownRefresh = pageConfig.enablePullDownRefresh;
            }
            if (typeof pageConfig.navigationStyle === 'string') {
                navigationStyle = pageConfig.navigationStyle;
            }
            if (typeof pageConfig.navigationBarTextStyle === 'string') {
                navigationBarTextStyle = pageConfig.navigationBarTextStyle;
            }
            if (typeof pageConfig.navigationBarBackgroundColor === 'string') {
                navigationBarBackgroundColor = pageConfig.navigationBarBackgroundColor;
            }
        }
        eventCenter.trigger('__taroSetNavigationStyle', navigationStyle, navigationBarTextStyle, navigationBarBackgroundColor);
        const currentPage = Current.page;
        const pathname = handler.pathname;
        const methodName = (_k = stacks.method) !== null && _k !== void 0 ? _k : '';
        const cacheTabs = stacks.getTabs();
        let shouldLoad = false;
        stacks.method = '';
        if (methodName === 'reLaunch') {
            handler.unload(currentPage, stacks.length);
            // NOTE: 同时卸载缓存在tabs里面的页面实例
            for (const key in cacheTabs) {
                if (cacheTabs[key]) {
                    handler.unload(cacheTabs[key]);
                    stacks.removeTab(key);
                }
            }
            shouldLoad = true;
        }
        else if (currentPage && handler.isTabBar(handler.pathname)) {
            if (handler.isSamePage(currentPage))
                return;
            if (handler.isTabBar(currentPage.path)) {
                handler.hide(currentPage);
                stacks.pushTab(currentPage.path.split('?')[0]);
            }
            else if (stacks.length > 0) {
                const firstIns = stacks.getItem(0);
                if (handler.isTabBar(firstIns.path)) {
                    handler.unload(currentPage, stacks.length - 1, true);
                    stacks.pushTab(firstIns.path.split('?')[0]);
                }
                else {
                    handler.unload(currentPage, stacks.length, true);
                }
            }
            if (cacheTabs[handler.pathname]) {
                stacks.popTab(handler.pathname);
                return handler.show(stacks.getItem(0), pageConfig, 0);
            }
            shouldLoad = true;
        }
        else if (action === 'POP') {
            // NOTE: 浏览器事件退后多次时，该事件只会被触发一次
            const prevIndex = stacks.getPrevIndex(pathname);
            const delta = stacks.getDelta(pathname);
            // NOTE: Safari 内核浏览器在非应用页面返回上一页时，会触发额外的 POP 事件，此处需避免当前页面被错误卸载
            if (currentPage !== stacks.getItem(prevIndex)) {
                handler.unload(currentPage, delta, prevIndex > -1);
                if (prevIndex > -1) {
                    eventCenter.once('__taroPageOnShowAfterDestroyed', () => {
                        handler.show(stacks.getItem(prevIndex), pageConfig, prevIndex);
                    });
                }
                else {
                    shouldLoad = true;
                }
            }
        }
        else if (action === 'REPLACE') {
            const delta = stacks.getDelta(pathname);
            // NOTE: 页面路由记录并不会清空，只是移除掉缓存的 stack 以及页面
            handler.unload(currentPage, delta);
            shouldLoad = true;
        }
        else if (action === 'PUSH') {
            handler.hide(currentPage);
            shouldLoad = true;
        }
        if (shouldLoad || stacks.length < 1) {
            const el = (_l = element.default) !== null && _l !== void 0 ? _l : element;
            const loadConfig = Object.assign({}, pageConfig);
            const stacksIndex = stacks.length;
            delete loadConfig['path'];
            delete loadConfig['load'];
            let pageStampId = '';
            if (launchStampId) {
                pageStampId = launchStampId;
                launchStampId = '';
            }
            else {
                pageStampId = createStampId();
            }
            const page = createPageConfig(enablePullDownRefresh ? hooks.call('createPullDownComponent', el, pathname, framework, handler.PullDownRefresh, pageStampId) : el, pathname + stringify(handler.getQuery(pageStampId)), {}, loadConfig);
            if (params)
                page.options = params;
            handler.load(page, pageConfig, pageStampId, stacksIndex);
        }
    });
    const routePath = addLeadingSlash(stripBasename(history.location.pathname, handler.basename));
    if (routePath === '/') {
        history.replace(prependBasename(handler.homePage + history.location.search));
    }
    render({ location: history.location, action: Action.Push });
    (_b = app.onShow) === null || _b === void 0 ? void 0 : _b.call(app, launchParam);
    return history.listen(render);
}

function handleAppMount(config, _, appId = config.appId || 'app') {
    let app = document.getElementById(appId);
    let isPosition = true;
    if (!app) {
        app = document.createElement('div');
        app.id = appId;
        isPosition = false;
    }
    const appWrapper = (app === null || app === void 0 ? void 0 : app.parentNode) || (app === null || app === void 0 ? void 0 : app.parentElement) || document.body;
    app.classList.add('taro_router');
    if (!isPosition)
        appWrapper.appendChild(app);
}
function handleAppMountWithTabbar(config, history, appId = config.appId || 'app') {
    let app = document.getElementById(appId);
    let isPosition = true;
    if (!app) {
        app = document.createElement('div');
        app.id = appId;
        isPosition = false;
    }
    const appWrapper = (app === null || app === void 0 ? void 0 : app.parentNode) || (app === null || app === void 0 ? void 0 : app.parentElement) || document.body;
    app.classList.add('taro_router');
    const container = document.createElement('div');
    container.classList.add('taro-tabbar__container');
    container.id = 'container';
    const panel = document.createElement('div');
    panel.classList.add('taro-tabbar__panel');
    panel.appendChild(app.cloneNode(true));
    container.appendChild(panel);
    if (!isPosition) {
        appWrapper.appendChild(container);
    }
    else {
        appWrapper.replaceChild(container, app);
    }
    initTabbar(config, history);
}

export { createMpaHistory, createMultiRouter, createRouter, getCurrentPages, handleAppMount, handleAppMountWithTabbar, history, isDingTalk, isWeixin, navigateBack, navigateTo, prependBasename, reLaunch, redirectTo, routesAlias, setHistory, setHistoryMode, setTitle, switchTab };
